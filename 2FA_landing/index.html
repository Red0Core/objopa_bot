<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OBJOPA 2FA</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: radial-gradient(circle at 20% 20%, #0c1024, #050712 60%, #02030a 100%);
      --card: rgba(255, 255, 255, 0.06);
      --stroke: rgba(255, 255, 255, 0.14);
      --muted: #94a3b8;
      --text: #e2e8f0;
      --accent: #a855f7;
      --accent-2: #22d3ee;
      --green: #34d399;
      font-family: "Inter", "SF Pro Text", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: max(14px, env(safe-area-inset-left));
      padding-right: max(14px, env(safe-area-inset-right));
      background: var(--bg);
      color: var(--text);
    }

    .page {
      width: min(420px, 100%);
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 18px;
      padding: clamp(14px, 4vw, 20px);
      box-shadow: 0 14px 45px rgba(0, 0, 0, 0.55);
      backdrop-filter: blur(12px);
      display: grid;
      gap: 14px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    h1 {
      margin: 0;
      font-size: clamp(17px, 4vw, 19px);
      letter-spacing: 0.08em;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.05);
      font-size: 12px;
      letter-spacing: 0.06em;
    }

    .otp-button {
      width: 100%;
      border: 1px solid var(--stroke);
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(34, 211, 238, 0.08));
      border-radius: 12px;
      padding: 12px;
      color: inherit;
      display: grid;
      gap: 8px;
      cursor: pointer;
      transition: transform 120ms ease, border-color 150ms ease;
    }

    .otp-button:active {
      transform: scale(0.98);
    }

    .otp-digits {
      display: flex;
      justify-content: center;
      gap: 8px;
      font-weight: 700;
      font-size: clamp(28px, 10vw, 38px);
      letter-spacing: 0.12em;
    }

    .otp-box {
      min-width: clamp(36px, 8vw, 44px);
      text-align: center;
      padding: 8px 0;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid transparent;
      transition: transform 160ms ease, background 160ms ease, border-color 160ms ease,
        box-shadow 160ms ease;
    }

    @keyframes copiedPulse {
      0% {
        transform: translateY(0) scale(1);
      }
      35% {
        transform: translateY(-2px) scale(1.02);
      }
      100% {
        transform: translateY(0) scale(1);
      }
    }

    .otp-button.copied .otp-box {
      border-color: var(--green);
      box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.28);
      background: linear-gradient(135deg, rgba(52, 211, 153, 0.15), rgba(168, 85, 247, 0.08));
      animation: copiedPulse 420ms ease;
    }

    .inline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .progress {
      width: 100%;
      height: 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      transform-origin: left;
      transition: width 300ms linear;
    }

    input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.02);
      color: inherit;
      font-size: 14px;
    }

    input:focus {
      outline: 1px solid var(--accent);
      border-color: var(--accent);
    }

    button.ghost {
      width: 100%;
      border: 1px dashed var(--stroke);
      background: transparent;
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: border-color 120ms ease;
      font-size: 14px;
    }

    button.ghost:active {
      border-color: var(--accent);
    }

    .meta {
      font-size: 12px;
      color: var(--muted);
    }

    @media (max-width: 380px) {
      .otp-digits {
        gap: 6px;
        letter-spacing: 0.1em;
      }
      .otp-box {
        min-width: 34px;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <h1>OBJOPA</h1>
      <span class="pill">
        <span style="width: 6px; height: 6px; border-radius: 50%; background: var(--accent);"></span>
        2FA
      </span>
    </header>

    <button class="otp-button" id="otp" type="button" aria-label="Скопировать код">
      <div class="inline">
        <span>OTP</span>
        <span id="remaining">30s</span>
      </div>
      <div class="otp-digits"></div>
      <div class="progress" aria-hidden="true">
        <span id="timer-fill"></span>
      </div>
    </button>

    <input
      id="secret"
      inputmode="text"
      autocomplete="one-time-code"
      placeholder="SECRET · BASE32"
      aria-label="Секрет в Base32"
    />
    <div class="inline" style="gap: 10px;">
      <button class="ghost" id="sync-btn" type="button" style="max-width: 120px;">Время</button>
      <div class="meta" id="drift" aria-live="polite">—</div>
    </div>
  </div>

  <script>
    var otpTag = document.getElementById("otp");
    var otpDigits = otpTag.querySelector(".otp-digits");
    var remainingTag = document.getElementById("remaining");
    var timerFill = document.getElementById("timer-fill");
    var secretInput = document.getElementById("secret");
    var syncBtn = document.getElementById("sync-btn");
    var driftTag = document.getElementById("drift");

    var pathSegments = window.location.pathname.split("/").filter(Boolean);
    var lastSegment = pathSegments.length ? pathSegments[pathSegments.length - 1] : "";
    var hasExtension = lastSegment.indexOf(".") !== -1;
    var initialPathSecret = pathSegments.length && !hasExtension
      ? decodeURIComponent(lastSegment)
      : "";
    var basePathSegments = initialPathSecret
      ? pathSegments.slice(0, -1)
      : pathSegments.slice();

    var cryptoKey = null;
    var secretBytes = null;
    var isUpdating = false;
    var lastLocalUnix = null;
    var lastSecret = "";

    function resetSecret() {
      cryptoKey = null;
      secretBytes = null;
      lastSecret = "";
    }

    function padStart(value, target, padChar) {
      var str = String(value);
      while (str.length < target) {
        str = padChar + str;
      }
      return str;
    }

    function extractSecretFromUrl() {
      var cleanedPathSecret = initialPathSecret.trim();
      if (cleanedPathSecret) {
        return cleanedPathSecret.replace(/\s+/g, "");
      }

      var params = new URLSearchParams(window.location.search);
      var otpauth = params.get("otpauth");
      if (!otpauth) return null;
      try {
        var url = new URL(otpauth);
        var secret = url.searchParams.get("secret");
        return secret ? secret.replace(/\s+/g, "") : null;
      } catch (error) {
        return null;
      }
    }

    function base32ToBytes(base32String) {
      var base32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      var cleaned = base32String.replace(/\s+/g, "");
      var bits = "";
      for (var i = 0; i < cleaned.length; i++) {
        var char = cleaned.charAt(i);
        var value = base32Alphabet.indexOf(char);
        if (value === -1) continue;
        var padded = value.toString(2);
        while (padded.length < 5) padded = "0" + padded;
        bits += padded;
      }
      var bytes = [];
      for (var j = 0; j + 8 <= bits.length; j += 8) {
        bytes.push(parseInt(bits.slice(j, j + 8), 2));
      }
      return new Uint8Array(bytes);
    }

    function prepareKey(secret) {
      return new Promise(function (resolve) {
        if (!secret) {
          resetSecret();
          return resolve();
        }

        var bytes = base32ToBytes(secret);
        if (!bytes.length) {
          resetSecret();
          return resolve();
        }

        secretBytes = bytes;
        lastSecret = secret;

        if (!crypto || !crypto.subtle || !crypto.subtle.importKey) {
          cryptoKey = null;
          return resolve();
        }

        crypto.subtle
          .importKey("raw", bytes, { name: "HMAC", hash: "SHA-1" }, false, ["sign"])
          .then(function (key) {
            cryptoKey = key;
            resolve();
          })
          .catch(function () {
            cryptoKey = null;
            resolve();
          });
      });
    }

    function leftRotate(value, bits) {
      return ((value << bits) | (value >>> (32 - bits))) >>> 0;
    }

    function sha1(bytes) {
      var words = [];
      var ml = bytes.length * 8;
      for (var i = 0; i < bytes.length; i++) {
        words[i >> 2] |= bytes[i] << (24 - (i % 4) * 8);
      }
      words[ml >> 5] |= 0x80 << (24 - (ml % 32));
      words[(((ml + 64) >> 9) << 4) + 15] = ml;

      var h0 = 0x67452301;
      var h1 = 0xefcdab89;
      var h2 = 0x98badcfe;
      var h3 = 0x10325476;
      var h4 = 0xc3d2e1f0;

      for (var i = 0; i < words.length; i += 16) {
        var w = words.slice(i, i + 16);
        for (var t = 16; t < 80; t++) {
          w[t] = leftRotate((w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]) >>> 0, 1);
        }

        var a = h0;
        var b = h1;
        var c = h2;
        var d = h3;
        var e = h4;

        for (var t = 0; t < 80; t++) {
          var f = 0;
          var k = 0;
          if (t < 20) {
            f = (b & c) | (~b & d);
            k = 0x5a827999;
          } else if (t < 40) {
            f = b ^ c ^ d;
            k = 0x6ed9eba1;
          } else if (t < 60) {
            f = (b & c) | (b & d) | (c & d);
            k = 0x8f1bbcdc;
          } else {
            f = b ^ c ^ d;
            k = 0xca62c1d6;
          }

          var temp = (leftRotate(a, 5) + f + e + k + (w[t] >>> 0)) >>> 0;
          e = d;
          d = c;
          c = leftRotate(b, 30);
          b = a;
          a = temp;
        }

        h0 = (h0 + a) >>> 0;
        h1 = (h1 + b) >>> 0;
        h2 = (h2 + c) >>> 0;
        h3 = (h3 + d) >>> 0;
        h4 = (h4 + e) >>> 0;
      }

      var result = new Uint8Array(20);
      var hashParts = [h0, h1, h2, h3, h4];
      for (var i = 0; i < hashParts.length; i++) {
        result[i * 4] = (hashParts[i] >>> 24) & 0xff;
        result[i * 4 + 1] = (hashParts[i] >>> 16) & 0xff;
        result[i * 4 + 2] = (hashParts[i] >>> 8) & 0xff;
        result[i * 4 + 3] = hashParts[i] & 0xff;
      }
      return result;
    }

    function hmacSha1(key, message) {
      var keyBytes = key;
      if (keyBytes.length > 64) {
        keyBytes = sha1(keyBytes);
      }

      var paddedKey = new Uint8Array(64);
      paddedKey.set(keyBytes);

      var oKeyPad = new Uint8Array(64);
      var iKeyPad = new Uint8Array(64);
      for (var i = 0; i < 64; i++) {
        oKeyPad[i] = paddedKey[i] ^ 0x5c;
        iKeyPad[i] = paddedKey[i] ^ 0x36;
      }

      var inner = new Uint8Array(64 + message.length);
      inner.set(iKeyPad, 0);
      inner.set(message, 64);
      var innerHash = sha1(inner);

      var outer = new Uint8Array(64 + innerHash.length);
      outer.set(oKeyPad, 0);
      outer.set(innerHash, 64);

      return sha1(outer);
    }

    function updateUrlWithSecret(secret) {
      var url = new URL(window.location.href);
      var segments = basePathSegments.slice();

      if (secret) {
        segments.push(encodeURIComponent(secret));
      }

      url.pathname = "/" + segments.join("/");
      window.history.replaceState({}, "", url);
    }

    function generateOtp(unixTime) {
      return new Promise(function (resolve) {
        if (!cryptoKey && !secretBytes) return resolve(null);
        var counter = Math.floor(unixTime / 30);
        var buffer = new ArrayBuffer(8);
        var view = new DataView(buffer);
        view.setUint32(4, counter, false);

        function handleHash(hash) {
          if (!hash) return resolve(null);
          var offset = hash[hash.length - 1] & 0x0f;
          var binary =
            ((hash[offset] & 0x7f) << 24) |
            ((hash[offset + 1] & 0xff) << 16) |
            ((hash[offset + 2] & 0xff) << 8) |
            (hash[offset + 3] & 0xff);
          resolve(padStart((binary % 1000000).toString(), 6, "0"));
        }

        if (cryptoKey) {
          crypto.subtle
            .sign("HMAC", cryptoKey, buffer)
            .then(function (signature) {
              handleHash(new Uint8Array(signature));
            })
            .catch(function () {
              resolve(null);
            });
        } else if (secretBytes) {
          handleHash(hmacSha1(secretBytes, new Uint8Array(buffer)));
        }
      });
    }

    function renderOtp(value) {
      var digits = padStart(value, 6, "-").slice(0, 6).split("");
      var html = digits
        .map(function (digit) {
          return '<span class="otp-box">' + digit + "</span>";
        })
        .join("");
      otpDigits.innerHTML = html;
    }

    function update() {
      if (isUpdating) return;
      isUpdating = true;
      var unixTime = Math.floor(Date.now() / 1000);
      lastLocalUnix = unixTime;
      var secondsLeft = 30 - (unixTime % 30);
      remainingTag.textContent = secondsLeft + "s";
      timerFill.style.width = secondsLeft / 30 * 100 + "%";

      if (!cryptoKey && !secretBytes) {
        renderOtp("------");
        isUpdating = false;
        return;
      }

      generateOtp(unixTime)
        .then(function (otp) {
          renderOtp(otp || "------");
          isUpdating = false;
        })
        .catch(function () {
          renderOtp("------");
          isUpdating = false;
        });
    }

    function copyOtp() {
      var value = otpDigits.textContent.replace(/\s+/g, "");
      if (!value || value.indexOf("-") !== -1) return;
      navigator.clipboard
        .writeText(value)
        .catch(function () {})
        .then(function () {
          otpTag.classList.add("copied");
          setTimeout(function () {
            otpTag.classList.remove("copied");
          }, 640);
        });
    }

    function fetchNetworkTime() {
      syncBtn.disabled = true;
      syncBtn.textContent = "...";
      fetch("https://worldtimeapi.org/api/ip", { cache: "no-store" })
        .then(function (response) {
          if (!response.ok) throw new Error("HTTP " + response.status);
          return response.json();
        })
        .then(function (data) {
          var networkUnix = Math.floor(data.unixtime);
          var currentLocal = lastLocalUnix || Math.floor(Date.now() / 1000);
          var drift = currentLocal - networkUnix;
          var signed = drift > 0 ? "+" + drift : String(drift);
          driftTag.textContent = signed + " сек";
        })
        .catch(function () {
          driftTag.textContent = "—";
        })
        .finally(function () {
          syncBtn.disabled = false;
          syncBtn.textContent = "Время";
        });
    }

    otpTag.addEventListener("click", copyOtp);

    secretInput.addEventListener("input", function (event) {
      var value = event.target.value.replace(/[^a-zA-Z2-7\s]/g, "").toUpperCase();
      event.target.value = value;
      updateUrlWithSecret(value);
      if (value === lastSecret) return;
      prepareKey(value).then(update);
    });

    syncBtn.addEventListener("click", fetchNetworkTime);

    var initialSecret = extractSecretFromUrl();
    if (initialSecret) {
      var normalized = initialSecret.toUpperCase();
      secretInput.value = normalized;
      updateUrlWithSecret(normalized);
      prepareKey(normalized).then(update);
    }

    setInterval(update, 1000);
    renderOtp("------");
    update();
  </script>
</body>
</html>
