<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><title>OBJOPA 2FA</title><style>:root {color-scheme: dark;--bg: radial-gradient(circle at 20% 20%, #0c1024, #050712 60%, #02030a 100%);--card: rgba(255, 255, 255, 0.06);--stroke: rgba(255, 255, 255, 0.14);--muted: #94a3b8;--text: #e2e8f0;--accent: #a855f7;--accent-2: #22d3ee;--green: #34d399;font-family: "Inter", "SF Pro Text", system-ui, -apple-system, sans-serif;}* {box-sizing: border-box;}body {margin: 0;min-height: 100vh;display: flex;align-items: center;justify-content: center;padding: max(14px, env(safe-area-inset-left));padding-right: max(14px, env(safe-area-inset-right));background: var(--bg);color: var(--text);}.page {width: min(420px, 100%);background: var(--card);border: 1px solid var(--stroke);border-radius: 18px;padding: clamp(14px, 4vw, 20px);box-shadow: 0 14px 45px rgba(0, 0, 0, 0.55);backdrop-filter: blur(12px);display: grid;gap: 14px;}header {display: flex;align-items: center;justify-content: space-between;gap: 10px;}h1 {margin: 0;font-size: clamp(17px, 4vw, 19px);letter-spacing: 0.08em;}.pill {display: inline-flex;align-items: center;justify-content: center;gap: 6px;padding: 6px 12px;border-radius: 999px;border: 1px solid var(--stroke);background: rgba(255, 255, 255, 0.05);font-size: 12px;letter-spacing: 0.06em;}.otp-button {width: 100%;border: 1px solid var(--stroke);background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(34, 211, 238, 0.08));border-radius: 12px;padding: 12px;color: inherit;display: grid;gap: 8px;cursor: pointer;transition: transform 120ms ease, border-color 150ms ease;}.otp-button:active {transform: scale(0.98);}.otp-digits {display: flex;justify-content: center;gap: 8px;font-weight: 700;font-size: clamp(28px, 10vw, 38px);letter-spacing: 0.12em;}.otp-box {min-width: clamp(36px, 8vw, 44px);text-align: center;padding: 8px 0;border-radius: 12px;background: rgba(255, 255, 255, 0.06);border: 1px solid transparent;transition: transform 160ms ease, background 160ms ease, border-color 160ms ease,box-shadow 160ms ease;}@keyframes copiedPulse {0% {transform: translateY(0) scale(1);}35% {transform: translateY(-2px) scale(1.02);}100% {transform: translateY(0) scale(1);}}.otp-button.copied .otp-box {border-color: var(--green);box-shadow: 0 0 0 1px rgba(52, 211, 153, 0.28);background: linear-gradient(135deg, rgba(52, 211, 153, 0.15), rgba(168, 85, 247, 0.08));animation: copiedPulse 420ms ease;}.inline {display: flex;align-items: center;justify-content: space-between;gap: 8px;font-size: 12px;color: var(--muted);}.progress {width: 100%;height: 4px;border-radius: 999px;background: rgba(255, 255, 255, 0.06);overflow: hidden;}.progress span {display: block;height: 100%;width: 100%;background: linear-gradient(90deg, var(--accent), var(--accent-2));transform-origin: left;transition: width 300ms linear;}input {width: 100%;padding: 10px 12px;border-radius: 10px;border: 1px solid var(--stroke);background: rgba(255, 255, 255, 0.02);color: inherit;font-size: 14px;}input:focus {outline: 1px solid var(--accent);border-color: var(--accent);}button.ghost {width: 100%;border: 1px dashed var(--stroke);background: transparent;color: var(--text);padding: 10px 12px;border-radius: 10px;cursor: pointer;transition: border-color 120ms ease;font-size: 14px;}button.ghost:active {border-color: var(--accent);}.meta {font-size: 12px;color: var(--muted);}@media (max-width: 380px) {.otp-digits {gap: 6px;letter-spacing: 0.1em;}.otp-box {min-width: 34px;}}</style></head><body><div class="page"><header><h1>OBJOPA</h1><span class="pill"><span style="width: 6px; height: 6px; border-radius: 50%; background: var(--accent);"></span>2FA</span></header><button class="otp-button" id="otp" type="button" aria-label="Скопировать код"><div class="inline"><span>OTP</span><span id="remaining">30s</span></div><div class="otp-digits"></div><div class="progress" aria-hidden="true"><span id="timer-fill"></span></div></button><inputid="secret"inputmode="text"autocomplete="one-time-code"placeholder="SECRET · BASE32"aria-label="Секрет в Base32"/><div class="inline" style="gap: 10px;"><button class="ghost" id="sync-btn" type="button" style="max-width: 120px;">Время</button><div class="meta" id="drift" aria-live="polite">—</div></div></div><script>const otpTag = document.getElementById("otp");const otpDigits = otpTag.querySelector(".otp-digits");const remainingTag = document.getElementById("remaining");const timerFill = document.getElementById("timer-fill");const secretInput = document.getElementById("secret");const syncBtn = document.getElementById("sync-btn");const driftTag = document.getElementById("drift");const pathSegments = window.location.pathname.split("/").filter(Boolean);const initialPathSecret = pathSegments.length? decodeURIComponent(pathSegments[pathSegments.length - 1]): "";const basePathSegments = initialPathSecret? pathSegments.slice(0, -1): pathSegments;let cryptoKey = null;let secretBytes = null;let isUpdating = false;let lastLocalUnix = null;let lastSecret = "";function extractSecretFromUrl() {const cleanedPathSecret = initialPathSecret.trim();if (cleanedPathSecret) {return cleanedPathSecret.replace(/\s+/g, "");}const params = new URLSearchParams(window.location.search);const otpauth = params.get("otpauth");if (!otpauth) return null;try {const url = new URL(otpauth);const secret = url.searchParams.get("secret");return secret?.replace(/\s+/g, "") ?? null;} catch (error) {return null;}}function base32ToBytes(base32String) {const base32Alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";const cleaned = base32String.replace(/\s+/g, "");let bits = "";for (const char of cleaned) {const value = base32Alphabet.indexOf(char);if (value === -1) continue;bits += value.toString(2).padStart(5, "0");}const bytes = [];for (let i = 0; i + 8 <= bits.length; i += 8) {bytes.push(parseInt(bits.slice(i, i + 8), 2));}return new Uint8Array(bytes);}async function prepareKey(secret) {if (!secret) {cryptoKey = null;secretBytes = null;lastSecret = "";return;}try {const bytes = base32ToBytes(secret);if (!bytes.length) throw new Error("empty");secretBytes = bytes;if (crypto?.subtle?.importKey) {cryptoKey = await crypto.subtle.importKey("raw",bytes,{ name: "HMAC", hash: "SHA-1" },false,["sign"]);} else {cryptoKey = null;}lastSecret = secret;} catch (error) {cryptoKey = null;secretBytes = null;lastSecret = "";}}function leftRotate(value, bits) {return ((value << bits) | (value >>> (32 - bits))) >>> 0;}function sha1(bytes) {const words = [];const ml = bytes.length * 8;for (let i = 0; i < bytes.length; i++) {words[i >> 2] |= bytes[i] << (24 - (i % 4) * 8);}words[ml >> 5] |= 0x80 << (24 - (ml % 32));words[(((ml + 64) >> 9) << 4) + 15] = ml;let h0 = 0x67452301;let h1 = 0xefcdab89;let h2 = 0x98badcfe;let h3 = 0x10325476;let h4 = 0xc3d2e1f0;for (let i = 0; i < words.length; i += 16) {const w = words.slice(i, i + 16);for (let t = 16; t < 80; t++) {w[t] = leftRotate((w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16]) >>> 0, 1);}let a = h0;let b = h1;let c = h2;let d = h3;let e = h4;for (let t = 0; t < 80; t++) {let f = 0;let k = 0;if (t < 20) {f = (b & c) | (~b & d);k = 0x5a827999;} else if (t < 40) {f = b ^ c ^ d;k = 0x6ed9eba1;} else if (t < 60) {f = (b & c) | (b & d) | (c & d);k = 0x8f1bbcdc;} else {f = b ^ c ^ d;k = 0xca62c1d6;}const temp = (leftRotate(a, 5) + f + e + k + (w[t] >>> 0)) >>> 0;e = d;d = c;c = leftRotate(b, 30);b = a;a = temp;}h0 = (h0 + a) >>> 0;h1 = (h1 + b) >>> 0;h2 = (h2 + c) >>> 0;h3 = (h3 + d) >>> 0;h4 = (h4 + e) >>> 0;}const result = new Uint8Array(20);const hashParts = [h0, h1, h2, h3, h4];for (let i = 0; i < hashParts.length; i++) {result[i * 4] = (hashParts[i] >>> 24) & 0xff;result[i * 4 + 1] = (hashParts[i] >>> 16) & 0xff;result[i * 4 + 2] = (hashParts[i] >>> 8) & 0xff;result[i * 4 + 3] = hashParts[i] & 0xff;}return result;}function hmacSha1(key, message) {let keyBytes = key;if (keyBytes.length > 64) {keyBytes = sha1(keyBytes);}const paddedKey = new Uint8Array(64);paddedKey.set(keyBytes);const oKeyPad = new Uint8Array(64);const iKeyPad = new Uint8Array(64);for (let i = 0; i < 64; i++) {oKeyPad[i] = paddedKey[i] ^ 0x5c;iKeyPad[i] = paddedKey[i] ^ 0x36;}const inner = new Uint8Array(64 + message.length);inner.set(iKeyPad, 0);inner.set(message, 64);const innerHash = sha1(inner);const outer = new Uint8Array(64 + innerHash.length);outer.set(oKeyPad, 0);outer.set(innerHash, 64);return sha1(outer);}function updateUrlWithSecret(secret) {const url = new URL(window.location.href);const segments = [...basePathSegments];if (secret) {segments.push(encodeURIComponent(secret));}url.pathname = `/${segments.join("/")}`;window.history.replaceState({}, "", url);}async function generateOtp(unixTime) {if (!cryptoKey && !secretBytes) return null;const counter = Math.floor(unixTime / 30);const buffer = new ArrayBuffer(8);const view = new DataView(buffer);view.setUint32(4, counter, false);let hash = null;if (cryptoKey) {const signature = await crypto.subtle.sign("HMAC", cryptoKey, buffer);hash = new Uint8Array(signature);} else if (secretBytes) {hash = hmacSha1(secretBytes, new Uint8Array(buffer));}if (!hash) return null;const offset = hash[hash.length - 1] & 0x0f;const binary =((hash[offset] & 0x7f) << 24) |((hash[offset + 1] & 0xff) << 16) |((hash[offset + 2] & 0xff) << 8) |(hash[offset + 3] & 0xff);return (binary % 1_000_000).toString().padStart(6, "0");}function renderOtp(value) {const digits = value.padStart(6, "-").slice(0, 6).split("");otpDigits.innerHTML = digits.map((digit) => `<span class="otp-box">${digit}</span>`).join("");}async function update() {if (isUpdating) return;isUpdating = true;const unixTime = Math.floor(Date.now() / 1000);lastLocalUnix = unixTime;const secondsLeft = 30 - (unixTime % 30);remainingTag.textContent = `${secondsLeft}s`;timerFill.style.width = `${(secondsLeft / 30) * 100}%`;if (!cryptoKey && !secretBytes) {renderOtp("------");isUpdating = false;return;}try {const otp = await generateOtp(unixTime);renderOtp(otp ?? "------");} catch (error) {renderOtp("------");} finally {isUpdating = false;}}async function copyOtp() {const value = otpDigits.textContent.replace(/\s+/g, "");if (!value || value.includes("-")) return;try {await navigator.clipboard.writeText(value);otpTag.classList.add("copied");setTimeout(() => otpTag.classList.remove("copied"), 640);} catch (error) {otpTag.classList.add("copied");setTimeout(() => otpTag.classList.remove("copied"), 640);}}async function fetchNetworkTime() {syncBtn.disabled = true;syncBtn.textContent = "...";try {const response = await fetch("https://worldtimeapi.org/api/ip", { cache: "no-store" });if (!response.ok) throw new Error(`HTTP ${response.status}`);const data = await response.json();const networkUnix = Math.floor(data.unixtime);const currentLocal = lastLocalUnix ?? Math.floor(Date.now() / 1000);const drift = currentLocal - networkUnix;const signed = drift > 0 ? `+${drift}` : `${drift}`;driftTag.textContent = `${signed} сек`;} catch (error) {driftTag.textContent = "—";} finally {syncBtn.disabled = false;syncBtn.textContent = "Время";}}otpTag.addEventListener("click", copyOtp);secretInput.addEventListener("input", (event) => {const value = event.target.value.replace(/[^a-zA-Z2-7\s]/g, "").toUpperCase();event.target.value = value;updateUrlWithSecret(value);if (value === lastSecret) return;prepareKey(value).then(update);});syncBtn.addEventListener("click", fetchNetworkTime);const initialSecret = extractSecretFromUrl();if (initialSecret) {const normalized = initialSecret.toUpperCase();secretInput.value = normalized;updateUrlWithSecret(normalized);prepareKey(normalized).then(update);}setInterval(update, 1000);renderOtp("------");update();</script></body></html>