<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OBJOPA 2FA</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: radial-gradient(circle at 20% 20%, #1c2740 0%, #0f172a 35%, #0b1224 100%);
      --glass: rgba(255, 255, 255, 0.08);
      --border: rgba(255, 255, 255, 0.12);
      --accent: #7c3aed;
      --accent-2: #22d3ee;
      --text-main: #e2e8f0;
      --muted: #94a3b8;
      --error: #f87171;
      --success: #34d399;
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: var(--bg);
      color: var(--text-main);
    }

    .shell {
      width: min(960px, 100%);
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
      border: 1px solid var(--border);
      border-radius: 28px;
      box-shadow:
        0 16px 60px rgba(0, 0, 0, 0.45),
        0 0 1px rgba(255, 255, 255, 0.18);
      padding: 32px;
      backdrop-filter: blur(18px);
      position: relative;
      overflow: hidden;
    }

    .shell::before,
    .shell::after {
      content: "";
      position: absolute;
      width: 280px;
      height: 280px;
      border-radius: 50%;
      filter: blur(90px);
      opacity: 0.8;
      pointer-events: none;
    }

    .shell::before {
      background: radial-gradient(circle, rgba(124, 58, 237, 0.5), rgba(15, 23, 42, 0));
      top: -80px;
      left: -60px;
    }

    .shell::after {
      background: radial-gradient(circle, rgba(34, 211, 238, 0.5), rgba(15, 23, 42, 0));
      bottom: -80px;
      right: -60px;
    }

    header {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
      margin-bottom: 22px;
    }

    .title {
      display: grid;
      gap: 6px;
    }

    .badge {
      padding: 6px 12px;
      border-radius: 10px;
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: #0b0f1a;
      font-weight: 700;
      letter-spacing: 0.04em;
      box-shadow: 0 12px 30px rgba(124, 58, 237, 0.35);
    }

    h1 {
      margin: 0;
      font-size: 30px;
      letter-spacing: 0.04em;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 18px;
    }

    .card {
      position: relative;
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px 18px 20px;
      overflow: hidden;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.08), rgba(34, 211, 238, 0.04));
      pointer-events: none;
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 17px;
      letter-spacing: 0.03em;
    }

    .input {
      width: 100%;
      padding: 14px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-main);
      outline: none;
      font-size: 16px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.18);
    }

    .otp-value {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 8px;
      margin: 6px 0 12px;
      font-size: 30px;
      font-weight: 800;
      letter-spacing: 0.04em;
      color: #f8fafc;
    }

    .otp-box {
      padding: 14px 12px;
      text-align: center;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      min-width: 42px;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      color: var(--muted);
      font-size: 14px;
    }

    .status.success {
      color: var(--success);
    }

    .status.error {
      color: var(--error);
    }

    .timer {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 12px;
    }

    .progress {
      position: relative;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.06);
      overflow: hidden;
    }

    .progress span {
      position: absolute;
      inset: 0;
      display: block;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      width: 100%;
      transform-origin: left center;
      transform: scaleX(0);
      transition: transform 0.2s ease;
    }

    .meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 13px;
    }

    .meta span {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.03);
    }

    @media (max-width: 520px) {
      h1 {
        font-size: 26px;
      }
      .otp-value {
        font-size: 38px;
      }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title">
        <span class="badge">OBJOPA</span>
        <h1>OBJOPA 2FA Authenticator</h1>
      </div>
      <div class="status" id="status">Готово офлайн</div>
    </header>

    <div class="grid">
      <div class="card">
        <h2>Base32 секрет</h2>
        <input
          id="secret"
          class="input"
          placeholder="Например: JBSWY3DPEHPK3PXP"
          autocomplete="off"
          spellcheck="false"
        />
      </div>

      <div class="card">
        <h2>Код</h2>
        <div class="otp-value" id="otp"></div>
        <div class="timer">
          <div class="progress"><span id="progress"></span></div>
          <div id="remaining">30s</div>
        </div>
      </div>

      <div class="card">
        <h2>Системное время</h2>
        <div class="meta">
          <span>UNIX: <strong id="unix">-</strong></span>
          <span>Обновление: каждые 30s</span>
          <span>Локально: без сетевых запросов</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const secretInput = document.getElementById("secret");
    const statusTag = document.getElementById("status");
    const otpTag = document.getElementById("otp");
    const progressFill = document.getElementById("progress");
    const remainingTag = document.getElementById("remaining");
    const unixTag = document.getElementById("unix");

    let cryptoKey = null;
    let lastSecret = "";
    let isUpdating = false;

    function base32ToBytes(secret) {
      const cleaned = secret.replace(/\s+/g, "").toUpperCase();
      const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      let bits = "";
      for (const char of cleaned) {
        const idx = alphabet.indexOf(char);
        if (idx === -1) {
          throw new Error(`Недопустимый символ: ${char}`);
        }
        bits += idx.toString(2).padStart(5, "0");
      }
      const bytes = [];
      for (let i = 0; i + 8 <= bits.length; i += 8) {
        bytes.push(parseInt(bits.slice(i, i + 8), 2));
      }
      return new Uint8Array(bytes);
    }

    async function prepareKey(secret) {
      if (!secret.trim()) {
        cryptoKey = null;
        lastSecret = "";
        setStatus("Готово офлайн", "");
        return;
      }
      try {
        const bytes = base32ToBytes(secret);
        if (!bytes.length) {
          throw new Error("Секрет пустой после декодирования");
        }
        cryptoKey = await crypto.subtle.importKey(
          "raw",
          bytes,
          { name: "HMAC", hash: "SHA-1" },
          false,
          ["sign"]
        );
        lastSecret = secret;
        setStatus("Секрет принят", "success");
      } catch (error) {
        cryptoKey = null;
        lastSecret = "";
        setStatus(error.message || "Ошибка секрета", "error");
      }
    }

    function setStatus(text, type) {
      statusTag.textContent = text;
      statusTag.className = `status${type ? " " + type : ""}`;
    }

    async function generateOtp(unixTime) {
      if (!cryptoKey) return null;
      const timeStep = 30;
      const counter = Math.floor(unixTime / timeStep);
      const counterBytes = new ArrayBuffer(8);
      const view = new DataView(counterBytes);
      view.setUint32(4, counter, false);
      const signature = await crypto.subtle.sign("HMAC", cryptoKey, counterBytes);
      const hash = new Uint8Array(signature);
      const offset = hash[hash.length - 1] & 0x0f;
      const binary =
        ((hash[offset] & 0x7f) << 24) |
        ((hash[offset + 1] & 0xff) << 16) |
        ((hash[offset + 2] & 0xff) << 8) |
        (hash[offset + 3] & 0xff);
      const otp = (binary % 1_000_000).toString().padStart(6, "0");
      return otp;
    }

    async function update() {
      if (isUpdating) return;
      isUpdating = true;
      const unixTime = Math.floor(Date.now() / 1000);
      unixTag.textContent = unixTime;
      const secondsLeft = 30 - (unixTime % 30);
      remainingTag.textContent = `${secondsLeft}s`;
      const progress = (secondsLeft / 30).toFixed(3);
      progressFill.style.transform = `scaleX(${progress})`;

      if (!cryptoKey) {
        renderOtp("------");
        isUpdating = false;
        return;
      }

      try {
        const otp = await generateOtp(unixTime);
        renderOtp(otp ?? "------");
      } catch (error) {
        renderOtp("------");
        setStatus("Ошибка генерации", "error");
      } finally {
        isUpdating = false;
      }
    }

    function renderOtp(value) {
      const digits = value.padStart(6, "-").slice(0, 6).split("");
      otpTag.innerHTML = digits
        .map((digit) => `<span class="otp-box">${digit}</span>`)
        .join("");
    }

    secretInput.addEventListener("input", (event) => {
      const value = event.target.value
        .replace(/[^a-zA-Z2-7\s]/g, "")
        .toUpperCase();
      event.target.value = value;
      if (value === lastSecret) return;
      prepareKey(value).then(update);
    });

    setInterval(update, 1000);
    renderOtp("------");
    update();
  </script>
</body>
</html>
